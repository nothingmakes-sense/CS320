# CS-320 Portfolio

This repository contains selected files from my coursework in software testing, automation, and quality assurance. From Project One, I've included the contact service implementation and tests: `Contact.java`, `ContactService.java`, `ContactTest.java`, and `ContactServiceTest.java`. These demonstrate my ability to build a simple contact management system using Java, with validation for data integrity (e.g., field length checks and null handling) and comprehensive unit tests using JUnit to verify functionality, handle invalid inputs, and ensure operations like adding, updating, and removing contacts work as expected. From Project Two, I've included the summary and reflections report (attached as a separate document in the repository).

Together, these artifacts highlight my skills in creating robust, testable code; applying unit testing to uncover errors; analyzing testing approaches based on requirements; and selecting appropriate strategies like white-box testing to meet functional needs.

## Reflections

### How can I ensure that my code, program, or software is functional and secure?
To ensure functionality, I prioritize writing comprehensive unit tests, as seen in the `ContactTest.java` and `ContactServiceTest.java` files, where I use JUnit assertions to validate constructors, setters, and service operations like append, pop, and update. This catches edge cases early, such as invalid lengths or null values, preventing runtime errors. For security, I incorporate input validation in the code (e.g., checking string lengths and formats in the `Contact` constructor) to mitigate risks like buffer overflows or injection attacks. Beyond that, I advocate for regular code reviews, static analysis tools, and adherence to secure coding standards like OWASP guidelines. In practice, integrating automated testing pipelines (e.g., CI/CD with tools like Jenkins) and conducting penetration testing further bolsters both functionality and security, ensuring the software remains reliable under various conditions.

### How do I interpret user needs and incorporate them into a program?
Interpreting user needs starts with gathering requirements through user stories, interviews, or prototypes to understand pain points and expectations. For instance, in the contact service project, user needs might include storing contacts with unique IDs, validating personal details, and supporting CRUD operations—needs I translated into class designs with private fields, setters, and service methods. I incorporate these by breaking them into modular components (e.g., separating data model in `Contact.java` from logic in `ContactService.java`), iterating based on feedback, and using agile practices to refine features. Testing plays a key role here too; the tests in this project simulate user scenarios, like creating invalid contacts, to ensure the program aligns with real-world use. Ultimately, this user-centric approach involves empathy mapping and continuous validation to build intuitive, effective software.

### How do I approach designing software?
My software design approach emphasizes object-oriented principles, modularity, and test-driven development (TDD). I start with high-level requirements, sketching out classes and interactions— for example, in this project, designing `Contact` as an immutable ID holder with mutable fields, and `ContactService` as a manager using an ArrayList for storage. I focus on separation of concerns to make code maintainable, like isolating validation logic in private methods. Then, I write tests first (as in the JUnit files) to guide implementation, ensuring designs are testable and robust. I also consider scalability and extensibility, such as using collections for easy expansion. Tools like UML diagrams help visualize before coding, and I iterate with refactoring to improve clarity. This methodical, principle-based process results in clean, efficient software that meets requirements while being adaptable to changes.
